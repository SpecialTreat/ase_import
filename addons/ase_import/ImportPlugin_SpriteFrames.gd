@tool
extends EditorImportPlugin


const AsepriteKit = preload("AsepriteKit.gd")
const AsepriteCommand = preload("AsepriteCommand.gd")
const AsepriteJson = preload("AsepriteJson.gd")
const SAVE_FLAGS: int = ResourceSaver.FLAG_CHANGE_PATH | ResourceSaver.FLAG_REPLACE_SUBRESOURCE_PATHS


func _get_importer_name() -> String:
	return "aseprite_animation_importer.SpriteFrames.plugin"

func _get_visible_name() -> String:
	return "Aseprite: SpriteFrames"

func _get_recognized_extensions() -> PackedStringArray:
	return ["aseprite", "ase"]

func _get_save_extension() -> String:
	return "tres"

func _get_resource_type() -> String:
	return "SpriteFrames"

func _get_priority() -> float:
	return 1.0

func _get_import_order() -> int:
	return IMPORT_ORDER_DEFAULT + 10

func _get_preset_count() -> int:
	return AsepriteKit._get_preset_count()

func _get_preset_name(preset_index: int) -> String:
	return AsepriteKit._get_preset_name(preset_index)

func _get_import_options(path: String, preset_index: int) -> Array:
	return AsepriteKit._get_import_options(preset_index)

func _get_option_visibility(path: String, option_name: StringName, options: Dictionary) -> bool:
	return AsepriteKit._get_option_visibility(path, option_name, options)


func _import(
	source_file: String,
	save_path: String,
	options: Dictionary,
	r_platform_variants: Array[String],
	r_gen_files: Array[String]
) -> int:

	var aseprite: AsepriteCommand = AsepriteCommand.new()
	var export_results: Array[Dictionary] = []
	var err: int = aseprite.export(source_file, save_path, options, r_platform_variants, r_gen_files, export_results)
	if err == ERR_UNCONFIGURED:
		AsepriteKit.print_invalid_aseprite_command()
		print("Aseprite import: aborted due to invalid aseprite command: %s" %  source_file)
	elif err != OK:
		return err
	elif export_results.is_empty():
		printerr("Aseprite import: failed due to empty export results: %s" % source_file)
		return ERR_INVALID_DATA

	if err != ERR_UNCONFIGURED:
		# Notify the editor of resources generated by AsepriteCommand.export()
		for export_info in export_results:
			if FileAccess.file_exists(export_info.sprite_sheet):
				append_import_external_resource(export_info.sprite_sheet)

		# Do the actual import
		for i in export_results.size():
			var export_info: Dictionary = export_results[i]
			var resource: Resource = make_resource(
				export_info,
				source_file,
				save_path,
				options,
				r_platform_variants,
				r_gen_files,
			)
			if not resource:
				err = FAILED
				return err

			var resource_path: String = "%s.%s" % [export_info.sprite_sheet.get_basename(), _get_save_extension()]
			err = save_resource(resource, resource_path)
			if err != OK:
				push_error("Aseprite importer error [%s]: failed to save sprite frames, %s" % [err, resource_path])
				return err

	# Save a placeholder resource so the editor doesn't complain
	var resource_path: String = "%s.%s" % [save_path, _get_save_extension()]
	var placeholder: SpriteFrames = SpriteFrames.new()
	if ResourceLoader.exists(resource_path):
		placeholder.take_over_path(resource_path)
	err = ResourceSaver.save(placeholder, resource_path)

	return err


func copy_resource(source: SpriteFrames, dest: SpriteFrames):
	dest.clear_all()
	for anim in source.get_animation_names():
		if not dest.has_animation(anim):
			dest.add_animation(anim)
		for idx in source.get_frame_count(anim):
			var texture: Texture2D = source.get_frame_texture(anim, idx)
			var duration: float = source.get_frame_duration(anim, idx)
			dest.add_frame(anim, texture, duration)
		dest.set_animation_loop(anim, source.get_animation_loop(anim))
		dest.set_animation_speed(anim, source.get_animation_speed(anim))


func save_resource(resource: SpriteFrames, resource_path: String) -> int:
	var err: int = OK
	# Three possibilities:
	if ResourceLoader.exists(resource_path):
		var existing = ResourceLoader.load(resource_path)
		if existing is SpriteFrames:
			# 1. The resource exists and is a SpriteFrames
			copy_resource(resource, existing)
			err = ResourceSaver.save(existing, resource_path, SAVE_FLAGS)
			if err != OK:
				printerr("Aseprite importer error [%s]: failed to save existing resource, %s" % [err, resource_path])
		else:
			# 2. The resource exists and is NOT a SpriteFrames
			resource.take_over_path(resource_path)
			err = ResourceSaver.save(resource, resource_path, SAVE_FLAGS)
			if err != OK:
				printerr("Aseprite importer error [%s]: failed to take over existing resource, %s" % [err, resource_path])
	else:
		# 3. The resource does not exist
		err = ResourceSaver.save(resource, resource_path, SAVE_FLAGS)
		if err != OK:
			printerr("Aseprite importer error [%s]: failed to take over existing resource, %s" % [err, resource_path])
	return err


func make_resource(
	export_info: Dictionary,
	source_file: String,
	save_path: String,
	options: Dictionary,
	r_platform_variants: Array,
	r_gen_files: Array,
) -> Resource:

	var import_data: AsepriteJson = AsepriteJson.new()
	var err: int = import_data.load(export_info.data_file)
	if err != OK:
		push_error("Aseprite importer error [%s]: failed to load json data, %s" % [err, export_info.data_file])
		return null

	if not(import_data and import_data.json_data):
		push_error("Aseprite importer error: missing json data, %s" % export_info.data_file)
		return null

	var default_loop: bool = false
	var frames: Array = import_data.get_frame_array()
	var frame_tags: Array = import_data.get_tags()
	if not frame_tags:
		frame_tags = [{
			name = "default_loop",
			from = 0,
			to = frames.size() - 1,
			direction = "forward",
		}]

	if len(frame_tags) == 1:
		var animation_name: String = frame_tags[0].name
		frame_tags[0].name = "default"
		default_loop = animation_name.ends_with("_loop") or animation_name.ends_with("_cycle")

	var sprite_frames: SpriteFrames = SpriteFrames.new()
	var texture: Texture2D = ResourceLoader.load(
		export_info.sprite_sheet,
		"CompressedTexture2D",
		ResourceLoader.CACHE_MODE_IGNORE
	) as Texture2D

	for tag in frame_tags:
		var selected_frames: Array = frames.slice(tag.from, tag.to + 1)
		_add_animation_frames(sprite_frames, tag.name, selected_frames, texture, tag.direction, default_loop, options)

	return sprite_frames


func _add_animation_frames(
	sprite_frames: SpriteFrames,
	animation_name: String,
	frames: Array,
	texture: Texture2D,
	direction: String,
	default_loop: bool,
	options: Dictionary,
):
	if animation_name != "default":
		sprite_frames.add_animation(animation_name)

	var loop: bool = default_loop or animation_name.ends_with("_loop") or animation_name.ends_with("_cycle")
	var min_duration: float = _get_min_duration(frames)
	var fps: float = _calculate_fps(min_duration, options)

	# Modify the frame order based on the tag's direction
	if direction == "reverse":
		frames.reverse()
	elif direction == "pingpong":
		var reverse_frames: Array = frames.slice(1, frames.size() - 2, 1, true)
		reverse_frames.reverse()
		frames += reverse_frames

	for frame in frames:
		var atlas: AtlasTexture = _create_atlas_texture_from_frame(texture, frame)
		var number_of_sprites = ceil(frame.duration / min_duration)
		for _i in range(number_of_sprites):
			sprite_frames.add_frame(animation_name, atlas)

	sprite_frames.set_animation_loop(animation_name, loop)
	sprite_frames.set_animation_speed(animation_name, fps)


func _create_atlas_texture_from_frame(texture: Texture2D, frame_data: Dictionary) -> AtlasTexture:
	var atlas: AtlasTexture = AtlasTexture.new()
	var frame = frame_data.frame
	atlas.atlas = texture
	atlas.region = Rect2(frame.x, frame.y, frame.w, frame.h)
	return atlas


func _calculate_fps(min_duration: float, options: Dictionary) -> float:
	var fps_snap: float = float(options.get("animation/fps_snap", -1.0))
	if fps_snap > 0.0:
		# Step to nearest 16.6667 seconds (nearest frame at 60 FPS)
		var duration: float = snapped(min_duration, (1000.0 / fps_snap))
		if duration <= 0.0:
			duration = 1000.0 / fps_snap
		return ceil(1000.0 / duration)
	else:
		return ceil(1000.0 / min_duration)


func _get_min_duration(frames: Array) -> float:
	if not frames:
		return 1.0 / 60.0

	var min_duration: float = frames[0].duration
	for frame in frames:
		if frame.duration < min_duration:
			min_duration = frame.duration
	return min_duration

@tool
extends EditorImportPlugin


const AsepriteKit = preload("AsepriteKit.gd")
const AsepriteCommand = preload("AsepriteCommand.gd")
const AsepriteJson = preload("AsepriteJson.gd")
const SAVE_FLAGS: int = ResourceSaver.FLAG_CHANGE_PATH | ResourceSaver.FLAG_REPLACE_SUBRESOURCE_PATHS


func _get_importer_name():
	return "aseprite_animation_importer.AnimationLibrary.plugin"

func _get_visible_name():
	return "Aseprite: AnimationLibrary"

func _get_recognized_extensions():
	return ["aseprite", "ase"]

func _get_save_extension():
	return "tres"

func _get_resource_type():
	return "AnimationLibrary"

func _get_priority():
	return 1.0

func _get_import_order() -> int:
	return IMPORT_ORDER_DEFAULT + 10

func _get_preset_count():
	return AsepriteKit._get_preset_count()

func _get_preset_name(preset_index: int):
	return AsepriteKit._get_preset_name(preset_index)

func _get_import_options(path: String, preset_index: int):
	return AsepriteKit._get_import_options(preset_index)

func _get_option_visibility(path: String, option_name: StringName, options: Dictionary):
	return AsepriteKit._get_option_visibility(path, option_name, options)


func _import(
	source_file: String,
	save_path: String,
	options: Dictionary,
	r_platform_variants: Array[String],
	r_gen_files: Array[String]
) -> int:

	var aseprite: AsepriteCommand = AsepriteCommand.new()
	var export_results: Array[Dictionary] = []
	var err: int = aseprite.export(source_file, save_path, options, r_platform_variants, r_gen_files, export_results)
	if err == ERR_UNCONFIGURED:
		AsepriteKit.print_invalid_aseprite_command()
		print("Aseprite import: aborted due to invalid aseprite command: %s" %  source_file)
	elif err != OK:
		return err
	elif export_results.is_empty():
		printerr("Aseprite import: failed due to empty export results: %s" % source_file)
		return ERR_INVALID_DATA

	if err != ERR_UNCONFIGURED:
		# Notify the editor of resources generated by AsepriteCommand.export()
		for export_info in export_results:
			if FileAccess.file_exists(export_info.sprite_sheet):
				append_import_external_resource(export_info.sprite_sheet)

		# Do the actual import
		var resource: Resource = make_resource(
			export_results,
			source_file,
			save_path,
			options,
			r_platform_variants,
			r_gen_files
		)
		var resource_path: String = "%s-AnimationLibrary.%s" % [source_file.get_basename(), _get_save_extension()]
		err = save_resource(resource, resource_path)
		if err != OK:
			printerr("Aseprite animation importer error [%s]: failed to save resource, %s" % [err, resource_path])
			return err

	# Save a placeholder resource so the editor doesn't complain
	var resource_path: String = "%s.%s" % [save_path, _get_save_extension()]
	var placeholder: AnimationLibrary = AnimationLibrary.new()
	if ResourceLoader.exists(resource_path):
		placeholder.take_over_path(resource_path)
	err = ResourceSaver.save(placeholder, resource_path)

	return err


func copy_resource(source: AnimationLibrary, dest: AnimationLibrary):
	for anim in dest.get_animation_list():
		dest.remove_animation(anim)
	for anim in source.get_animation_list():
		if not dest.has_animation(anim):
			dest.add_animation(anim, source.get_animation(anim))


func save_resource(resource: AnimationLibrary, resource_path: String) -> int:
	var err: int = OK
	# Three possibilities:
	if ResourceLoader.exists(resource_path):
		var existing = ResourceLoader.load(resource_path)
		if existing is AnimationLibrary:
			# 1. The resource exists and is a AnimationLibrary
			copy_resource(resource, existing)
			err = ResourceSaver.save(existing, resource_path, SAVE_FLAGS)
			if err != OK:
				printerr("Aseprite importer error [%s]: failed to save existing resource, %s" % [err, resource_path])
		else:
			# 2. The resource exists and is NOT a AnimationLibrary
			resource.take_over_path(resource_path)
			err = ResourceSaver.save(resource, resource_path, SAVE_FLAGS)
			if err != OK:
				printerr("Aseprite importer error [%s]: failed to take over existing resource, %s" % [err, resource_path])
	else:
		# 3. The resource does not exist
		err = ResourceSaver.save(resource, resource_path, SAVE_FLAGS)
		if err != OK:
			printerr("Aseprite importer error [%s]: failed to take over existing resource, %s" % [err, resource_path])
	return err


func make_resource(
	export_results: Array[Dictionary],
	source_file: String,
	save_path: String,
	options: Dictionary,
	r_platform_variants: Array,
	r_gen_files: Array,
) -> Resource:

	var animate_position_regex: RegEx = null
	if options.get("animate_position/enabled") and options.get("animate_position/include_pattern"):
		var pattern: String = options.get("animate_position/include_pattern")
		animate_position_regex = RegEx.new()
		var err: int = animate_position_regex.compile(pattern)
		if err != OK:
			push_error("Regex error [%s]: %s" % [err, pattern])
			animate_position_regex = null

	var animations: AnimationLibrary = AnimationLibrary.new()
	for export_info in export_results:
		var import_data: AsepriteJson = AsepriteJson.new()
		if import_data.load(export_info.data_file) != OK:
			push_error("Aseprite animation importer error: failed to load json data, %s" % export_info.data_file)
			continue

		if not(import_data and import_data.json_data):
			push_error("Aseprite animation importer error: missing json data, %s" % export_info.data_file)
			continue

		var frame_tags: Array = import_data.get_tags()
		var frames: Array = import_data.get_frame_array()
		var fps_snap: float = float(options.get("animation/fps_snap", -1.0))
		if fps_snap > 0.0:
			var min_duration: float = 1000.0 / fps_snap
			for frame in frames:
				if frame.duration > 0.0:
					var duration: float = snapped(frame.duration, min_duration)
					if duration <= 0.0:
						duration = min_duration
					frame.duration = duration

		var track_path: String
		if options.get("animation/track_name_template"):
			track_path = AsepriteKit.render_template(options.get("animation/track_name_template"), export_info)
		else:
			track_path = export_info.sprite_sheet.get_basename().get_file()

		var tracks: Dictionary = {}

		var animate_property: String = "offset"
		var omit_region: bool = false
		if animate_position_regex and animate_position_regex.search(track_path):
			animate_property = "position"
			omit_region = true

		if not omit_region:
			tracks["region"] = {"path": "%s:region_rect" % track_path}

		tracks[animate_property] = {"path": "%s:%s" % [track_path, animate_property]}

		if options.get("occluders/enable_generation", false) and frames and "occluderNode" in frames[0]:
			var track_name_template: String = options.get("occluders/track_name_template", "{layer}_LightOccluder")
			tracks["occluders"] = {
				"path": "%s:active_occluder" % AsepriteKit.render_template(track_name_template, export_info)
			}

		# Iterate over each tag (animation)
		for tag in frame_tags:
			if not animations.has_animation(tag.name):
				animations.add_animation(tag.name, Animation.new())
			var animation: Animation = animations.get_animation(tag.name)

			# Setup the animation tracks
			for track_name in tracks:
				var track: Dictionary = tracks[track_name]

				track.idx = animation.find_track(track.path, Animation.TYPE_VALUE)

				# Checks if the track doesn't  exist
				if track.idx == -1:
					# Create a new_track
					track.idx = animation.add_track(Animation.TYPE_VALUE)
					animation.track_set_path(track.idx, track.path)
				else:
					# Remove all existing keys from the track
					for key_idx in range(animation.track_get_key_count(track.idx)):
						animation.track_remove_key(track.idx, 0)

				# Set the track Interpolation Mode to Nearest
				animation.track_set_interpolation_type(track.idx, Animation.INTERPOLATION_NEAREST)
				#Enable the track
				animation.track_set_enabled(track.idx, true)

			var loop: bool = tag.name.ends_with("_loop") or tag.name.ends_with("_cycle")
			animation.loop_mode = Animation.LOOP_LINEAR if loop else Animation.LOOP_NONE

			var time: float = 0.0
			var frame_idxs: Array = range(tag.from, tag.to + 1)

			# Modify the frame order based on the tag's direction
			match tag.direction:
				"reverse":
					frame_idxs.reverse()
				"pingpong":
					var pong_frame_idxs := range(tag.from + 1, tag.to)
					pong_frame_idxs.reverse()
					frame_idxs += pong_frame_idxs

			# Insert the new keys
			for i in frame_idxs:
				var frame: Dictionary = frames[i]

				if not omit_region:
					# Get the region of the spritesheet that has the frame
					var rect = frame.frame
					var region = Rect2(rect.x, rect.y, rect.w, rect.h)

					# Insert the new key for the region track
					animation.track_insert_key(tracks.region.idx, time, region)

				# Get the center of the frame in the original size
				var source_size: Dictionary = frame.sourceSize
				var source_center_x: float = source_size.w / 2.0
				var source_center_y: float = source_size.h / 2.0

				# Get the center of the trimmed frame in the spritesheet
				var trim_rect: Dictionary = frame.spriteSourceSize
				var trim_rect_center_x: float = trim_rect.x + (trim_rect.w / 2.0)
				var trim_rect_center_y: float = trim_rect.y + (trim_rect.h / 2.0)

				# Calculate the offset between the trimmed frame center and original frame center
				var offset_x := trim_rect_center_x - source_center_x
				var offset_y := trim_rect_center_y - source_center_y
				if options.get("animation/invert_y", false):
					offset_y = -offset_y

				# Insert the new key for the offset track
				if animate_property == "offset":
					animation.track_insert_key(tracks.offset.idx, time, Vector2(offset_x, offset_y))
				else:
					var use_vector3: bool = options.get("animate_position/use_vector3", false)
					var position = Vector3(offset_x, offset_y, 0.0) if use_vector3 else Vector2(offset_x, offset_y)
					var pixel_scale: float = options.get("animate_position/pixel_scale", 0.05)
					animation.track_insert_key(tracks.position.idx, time, position * pixel_scale)

				if options.get("occluders/enable_generation", false) and "occluderNode" in frame:
					animation.track_insert_key(tracks.occluders.idx, time, frame.occluderNode)

				# Add up the current frame's duration for the next key position
				time += frame.duration / 1000.0

			# Set the animation length equal to the sum of all frame's durations
			animation.length = time

	return animations
